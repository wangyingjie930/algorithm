### 二叉树套路解
- 定义好函数的含义并定义好basecase f()
- 如果向左子树, 则为 f(左子树之后的情况)
- 如果向右子树, 则为 f(右子树之后的情况)

### 动态规划套路解
- 首先根据条件可以实现递归的版本
    - 另外可以实现记忆化搜索, 也就是在递归里面加数组, 相当于缓存数据,不用进行重复地运算
- 根据递归的条件可以忽略题目本身的含义进行转换成动态规划
    1. 确定可变参数, 2个, 那就是二维数组
    2. 确定终止位置
    3. 确定basecase
    4. 对于普遍的位置, 看依赖与其他的位置
    5. 确定依赖的顺序 e.g.因为他是依赖于下方的位置, 那么就从数组底部开始遍历

### 单调栈 (O(n))
- 单调栈应用范围不算大，它仅适合解决NEG问题，即Next Greater Element，下一个更大元素。注意，这里也可以更小的元素，也可以是前一个。
- 参考: 
  - https://www.bilibili.com/video/BV1vu411r733/?vd_source=c0808a52efcf11b005f1df5936845dd2
  - http://toughcoder.net/blog/2022/08/15/secret-weapon-monotonic-stack/

### 双指针 (O(n))
- 前提: 有序数组
- 类别:
  - 同向指针
  - 相向指针
  - 背向指针

### 概率
- 不均匀硬币产生等概率
- 均匀硬币产生不等概率

### 回溯
- 区别于动态规划: 
  - 动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求
  - 回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高