#### 关于go的引用(对比指针)
- 首先指针可以说是透明的引用, 但是需要了解底层细节, 程序更容易出错
- 引用可以说是不透明的引用, 让它看起来像一个**直接访问**的值
- 其他语言(Python/PHP)的引用:![其他语言的引用.png](assets%2F%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BC%95%E7%94%A8.png)
- go的引用类型: 针对**特定类型**的优化, 在值与指针之间**折中**
  - Go 引用的实现逻辑却内置在 runtime 里，不仅无法直接访问元数据，还表现得像在直接操作目标数据。你会以为它是个普通的值，直到某些行为跟想象中不一样，才想起了解它的底层结构。如果不去看 runtime 的源码，这些元数据结构体仿佛不存在
  - 引用类型如下:
    - string
    - slice
    - map
    - func
    - interface
    - chan

### new() 与 make()区别
new(T): 返回指针, 适用于值类型，如数组、结构体等。
make(T,args): 返回引用, 只适用于 slice、map 和 channel
```go
func main() {
	//不能通过编译, new返回的是指针, make返回的是引用, 切片是引用类型的(go把引用的细节封装了), 要用make方法
    list := new([]int)
    list = append(list, 1)
    fmt.Println(list)
}
```

### init函数
- 用于程序执行前做包的初始化的函数，比如**初始化包里的变量**等
- 一个包可以出现**多个 init()** 函数,一个源文件也可以包含多个 init() 函数
- 同一个包中多个 init() 函数的**执行顺序没有明确定义**
- init() 函数在代码中不能被显示调用、不能被引用（赋值给函数变量），否则出现编译错误
- 一个包被引用多次，如 A import B,C import B,A import C，B 被引用多次，但 B 包只会初始化一次；
- 引入包，不可出现死循坏。即 A import B,B import A，这种情况编译失败
- ![init.png](assets%2Finit.png)

### cap函数使用的类型
- cap() 函数通常适用于字符串、切片、数组等类型，可以用来获取这些类型的容量
- 对于大多数内置类型（如数值类型和布尔类型）和字典类型，cap() 函数是不适用的，因为它们没有容量的概念

### 零值
- 引用类型和指针类型的零值为nil (引用类型在上面有介绍)
- bool零值为false, string零值为"", 值类型的零值为0
- 数组和结构体会根据元素/属性的类型对应不同的零值